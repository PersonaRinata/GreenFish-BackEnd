// Code generated by hertz generator.

package api

import (
	consts2 "GreenFish/server/common/consts"
	"GreenFish/server/common/middleware"
	"GreenFish/server/common/tools"
	"GreenFish/server/kitex_gen/aigc"
	base2 "GreenFish/server/kitex_gen/base"
	"GreenFish/server/kitex_gen/chat"
	"GreenFish/server/kitex_gen/interaction"
	"GreenFish/server/kitex_gen/sociality"
	"GreenFish/server/kitex_gen/user"
	"GreenFish/server/kitex_gen/video"
	"GreenFish/server/service/api/biz/model/api"
	"GreenFish/server/service/api/biz/model/base"
	"GreenFish/server/service/api/config"
	"GreenFish/server/service/api/pkg"
	"context"
	"errors"
	"fmt"
	"github.com/bwmarrin/snowflake"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/jinzhu/copier"
	"os"
	"strconv"
	"strings"
	"time"
)

// Register .
// @router /qingyu/user/register/ [POST]
func Register(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuUserRegisterRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api register bindAndValidate failed", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(api.QingyuUserRegisterResponse)
	cg := config.GlobalUserClient
	res, err := cg.Register(ctx, &user.QingyuUserRegisterRequest{
		Username: req.Username,
		Password: req.Password,
	})
	if err != nil {
		hlog.Error("rpc call user_srv failed,", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp = &api.QingyuUserRegisterResponse{
		StatusCode: res.BaseResp.StatusCode,
		StatusMsg:  res.BaseResp.StatusMsg,
		UserID:     res.UserId,
		Token:      res.Token,
	}
	c.JSON(consts.StatusOK, resp)
}

// Login .
// @router /qingyu/user/login/ [POST]
func Login(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuUserLoginRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api login bindAndValidate failed", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	cg := config.GlobalUserClient
	res, err := cg.Login(ctx, &user.QingyuUserLoginRequest{
		Username: req.Username,
		Password: req.Password,
	})
	if err != nil {
		hlog.Error("call user_srv failed,", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	resp := new(api.QingyuUserLoginResponse)
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	resp.Token = res.Token
	resp.UserID = res.UserId
	c.JSON(consts.StatusOK, resp)
}

// GetUserInfo .
// @router /qingyu/user/ [GET]
func GetUserInfo(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuUserRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api getUserInfo bindAndValidate failed", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	viewerId, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get viewerId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}
	res, err := config.GlobalUserClient.GetUserInfo(ctx, &user.QingyuGetUserRequest{
		ViewerId: viewerId.(int64),
		OwnerId:  req.UserID,
	})
	if err != nil {
		hlog.Error("rpc call user_srv failed,", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp := new(api.QingyuUserResponse)
	resp.User = &base.User{
		ID:              res.User.Id,
		Name:            res.User.Name,
		FollowCount:     res.User.FollowCount,
		FollowerCount:   res.User.FollowerCount,
		IsFollow:        res.User.IsFollow,
		Avatar:          res.User.Avatar,
		BackgroundImage: res.User.BackgroundImage,
		Signature:       res.User.Signature,
		TotalFavorited:  res.User.TotalFavorited,
		WorkCount:       res.User.WorkCount,
		FavoriteCount:   res.User.FavoriteCount,
	}
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	c.JSON(consts.StatusOK, resp)
}

// Feed .
// @router /qingyu/feed/ [GET]
func Feed(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuFeedRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api feed bindAndValidate failed,", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp := new(api.QingyuFeedResponse)
	var viewerId int64
	token := req.Token
	if token != "" {
		j := middleware.NewJWT(config.GlobalServerConfig.JWTInfo.SigningKey)
		claims, err := j.ParseToken(req.Token)
		if err != nil {
			resp.StatusCode = 400
			resp.StatusMsg = "bad token"
			c.String(consts.StatusBadRequest, err.Error())
			return
		}
		viewerId = claims.ID
	}
	res, err := config.GlobalVideoClient.Feed(ctx, &video.QingyuFeedRequest{
		LatestTime: req.LatestTime,
		ViewerId:   viewerId,
	})
	if err != nil {
		hlog.Error("api call video_srv failed,", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	resp.NextTime = res.NextTime
	for _, v := range res.VideoList {
		resp.VideoList = append(resp.VideoList, &base.Video{
			ID: v.Id,
			Author: &base.User{
				ID:              v.Author.Id,
				Name:            v.Author.Name,
				FollowCount:     v.Author.FollowCount,
				FollowerCount:   v.Author.FollowerCount,
				IsFollow:        v.Author.IsFollow,
				Avatar:          v.Author.Avatar,
				BackgroundImage: v.Author.BackgroundImage,
				Signature:       v.Author.Signature,
				TotalFavorited:  v.Author.TotalFavorited,
				WorkCount:       v.Author.WorkCount,
				FavoriteCount:   v.Author.FavoriteCount,
			},
			PlayURL:       v.PlayUrl,
			CoverURL:      v.CoverUrl,
			FavoriteCount: v.FavoriteCount,
			CommentCount:  v.CommentCount,
			IsFavorite:    v.IsFavorite,
			Title:         v.Title,
		})
	}
	c.JSON(consts.StatusOK, resp)
}

// PublishVideo .
// @router /qingyu/publish/action/ [POST]
func PublishVideo(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuPublishActionRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api publishVideo bindAndValidate failed,", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	userId, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get viewerId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}
	resp := new(api.QingyuPublishActionResponse)
	_, flag = c.GetQuery("data")
	if !flag {
		hlog.Info("get data success")
	} else {
		hlog.Info("get data failed")
	}
	fileHeader, err := c.Request.FormFile("data")
	if err != nil {
		hlog.Error("api read video file failed,err", err)
		resp.StatusCode = 500
		resp.StatusMsg = "get publish video formFile failed"
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	s := strings.Split(fileHeader.Filename, ".")
	s2 := s[len(s)-1:]
	suffix := strings.Join(s2, "")
	sf, err := snowflake.NewNode(consts2.MinioSnowFlakeNode)
	if err != nil {
		hlog.Error("minio snowFlake generate failed,", err)
		c.String(consts.StatusInternalServerError, err.Error())
	}
	id := sf.Generate().String()
	uploadPathBase := time.Now().Format("2006/01/02/") + id
	VTmpPath := "./tmp/video/" + id + "." + suffix
	CTmpPath := "./tmp/cover/" + id + ".png"
	VUpPath := uploadPathBase + "." + suffix
	CUpPath := uploadPathBase + ".png"
	videoFile, err := os.Create("./tmp/video/" + id + "." + suffix)
	if err != nil {
		hlog.Error("tmp create video failed")
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	defer videoFile.Close()

	mpFile, err := fileHeader.Open()
	if err != nil {
		hlog.Error("fileHeader open failed")
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	defer mpFile.Close()

	_, err = videoFile.ReadFrom(mpFile)
	if err != nil {
		hlog.Error("readFrom from mpFile failed", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	err = pkg.MinioVideoUpgrade(suffix, VTmpPath, VUpPath)
	if err != nil {
		hlog.Error("api_srv upgrade video failed,", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	err = tools.GetVideoCover(VTmpPath, CTmpPath)
	if err != nil {
		hlog.Error("api_srv upgrade minio object failed,", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	err = pkg.MinioCoverUpgrade(CTmpPath, CUpPath)
	if err != nil {
		hlog.Error("api_srv upgrade cover failed,", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	res, err := config.GlobalVideoClient.PublishVideo(ctx, &video.QingyuPublishActionRequest{
		UserId:   userId.(int64),
		PlayUrl:  config.GlobalServerConfig.MinioInfo.UrlPrefix + VUpPath,
		CoverUrl: config.GlobalServerConfig.MinioInfo.UrlPrefix + CUpPath,
		Title:    req.Title,
	})
	if err != nil {
		hlog.Error("api call video_srv failed,", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	c.JSON(consts.StatusOK, resp)
}

// VideoList .
// @router /qingyu/publish/list/ [GET]
func VideoList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuPublishListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api videoList bindAndValidate failed,", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	viewId, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get viewerId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}
	resp := new(api.QingyuPublishListResponse)
	res, err := config.GlobalVideoClient.GetPublishedVideoList(ctx, &video.QingyuGetPublishedListRequest{
		ViewerId: viewId.(int64),
		OwnerId:  req.UserID,
	})
	if err != nil {
		hlog.Error("api get videoList failed,", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	for _, v := range res.VideoList {
		resp.VideoList = append(resp.VideoList, &base.Video{
			ID: v.Id,
			Author: &base.User{
				ID:              v.Author.Id,
				Name:            v.Author.Name,
				FollowCount:     v.Author.FollowCount,
				FollowerCount:   v.Author.FollowerCount,
				IsFollow:        v.Author.IsFollow,
				Avatar:          v.Author.Avatar,
				BackgroundImage: v.Author.BackgroundImage,
				Signature:       v.Author.Signature,
				TotalFavorited:  v.Author.TotalFavorited,
				WorkCount:       v.Author.WorkCount,
				FavoriteCount:   v.Author.FavoriteCount,
			},
			PlayURL:       v.PlayUrl,
			CoverURL:      v.CoverUrl,
			FavoriteCount: v.FavoriteCount,
			CommentCount:  v.CommentCount,
			IsFavorite:    v.IsFavorite,
			Title:         v.Title,
		})
	}
	c.JSON(consts.StatusOK, resp)
}

// Favorite .
// @router /qingyu/favorite/action/ [POST]
func Favorite(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuFavoriteActionRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api favorite bindAndValidate failed,", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	userId, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get viewerId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}
	resp := new(api.QingyuFavoriteActionResponse)
	res, err := config.GlobalInteractionClient.Favorite(ctx, &interaction.QingyuFavoriteActionRequest{
		UserId:     userId.(int64),
		VideoId:    req.VideoID,
		ActionType: req.ActionType,
	})
	if err != nil {
		hlog.Error("api call interaction rpc failed,", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	c.JSON(consts.StatusOK, resp)
}

// FavoriteList .
// @router /qingyu/favorite/list/ [GET]
func FavoriteList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuFavoriteListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api favoriteList bindAndValidate failed,", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	viewerId, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get viewerId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}
	res, err := config.GlobalVideoClient.GetFavoriteVideoList(ctx, &video.QingyuGetFavoriteListRequest{
		ViewerId: viewerId.(int64),
		OwnerId:  req.UserID,
	})
	if err != nil {
		hlog.Error("api call video_srv failed,", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	resp := new(api.QingyuFavoriteListResponse)
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	for _, v := range res.VideoList {
		resp.VideoList = append(resp.VideoList, &base.Video{
			ID: v.Id,
			Author: &base.User{
				ID:              v.Author.Id,
				Name:            v.Author.Name,
				FollowCount:     v.Author.FollowCount,
				FollowerCount:   v.Author.FollowerCount,
				IsFollow:        v.Author.IsFollow,
				Avatar:          v.Author.Avatar,
				BackgroundImage: v.Author.BackgroundImage,
				Signature:       v.Author.Signature,
				TotalFavorited:  v.Author.TotalFavorited,
				WorkCount:       v.Author.WorkCount,
				FavoriteCount:   v.Author.FavoriteCount,
			},
			PlayURL:       v.PlayUrl,
			CoverURL:      v.CoverUrl,
			FavoriteCount: v.FavoriteCount,
			CommentCount:  v.CommentCount,
			IsFavorite:    v.IsFavorite,
			Title:         v.Title,
		})
	}

	c.JSON(consts.StatusOK, resp)
}

// Comment .
// @router /qingyu/comment/action/ [POST]
func Comment(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuCommentActionRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api comment bindAndValidate failed,", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	userId, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get viewerId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}
	res, err := config.GlobalInteractionClient.Comment(ctx, &interaction.QingyuCommentActionRequest{
		UserId:      userId.(int64),
		VideoId:     req.VideoID,
		ActionType:  req.ActionType,
		CommentText: req.CommentText,
		CommentId:   req.CommentID,
	})
	if err != nil {
		hlog.Error("api call interaction_srv failed,", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	resp := new(api.QingyuCommentActionResponse)
	resp.Comment = &base.Comment{
		ID: res.Comment.Id,
		User: &base.User{
			ID:              res.Comment.User.Id,
			Name:            res.Comment.User.Name,
			FollowCount:     res.Comment.User.FollowerCount,
			FollowerCount:   res.Comment.User.FollowerCount,
			IsFollow:        res.Comment.User.IsFollow,
			Avatar:          res.Comment.User.Avatar,
			BackgroundImage: res.Comment.User.BackgroundImage,
			Signature:       res.Comment.User.Signature,
			TotalFavorited:  res.Comment.User.TotalFavorited,
			WorkCount:       res.Comment.User.WorkCount,
			FavoriteCount:   res.Comment.User.FavoriteCount,
		},
		Content:    res.Comment.Content,
		CreateDate: res.Comment.CreateDate,
	}
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	c.JSON(consts.StatusOK, resp)
}

// CommentList .
// @router /qingyu/comment/list/ [GET]
func CommentList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuCommentListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api commentList bindAndValidate failed,", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	res, err := config.GlobalInteractionClient.GetCommentList(ctx, &interaction.QingyuGetCommentListRequest{VideoId: req.VideoID})
	if err != nil {
		hlog.Error("api call interaction_srv failed,", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	resp := new(api.QingyuCommentListResponse)
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	for _, v := range res.CommentList {
		resp.CommentList = append(resp.CommentList, &base.Comment{
			ID: v.Id,
			User: &base.User{
				ID:              v.User.Id,
				Name:            v.User.Name,
				FollowCount:     v.User.FollowerCount,
				FollowerCount:   v.User.FollowerCount,
				IsFollow:        v.User.IsFollow,
				Avatar:          v.User.Avatar,
				BackgroundImage: v.User.BackgroundImage,
				Signature:       v.User.Signature,
				TotalFavorited:  v.User.TotalFavorited,
				WorkCount:       v.User.WorkCount,
				FavoriteCount:   v.User.FavoriteCount,
			},
			Content:    v.Content,
			CreateDate: v.CreateDate,
		})
	}
	c.JSON(consts.StatusOK, resp)
}

// Action .
// @router /qingyu/relation/action/ [POST]
func Action(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuRelationActionRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api action bindAndValidate failed,", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	userId, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get viewerId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}
	res, err := config.GlobalSocialClient.Action(ctx, &sociality.QingyuRelationActionRequest{
		UserId:     userId.(int64),
		ToUserId:   req.ToUserID,
		ActionType: req.ActionType,
	})
	if err != nil {
		hlog.Error("api call sociality rpc failed,", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	resp := new(api.QingyuRelationActionResponse)
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode

	c.JSON(consts.StatusOK, resp)
}

// FollowingList .
// @router /qingyu/relation/follow/list/ [GET]
func FollowingList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuRelationFollowListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api followingList bindAndValidate failed,", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	viewId, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get viewerId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}
	res, err := config.GlobalUserClient.GetFollowList(ctx, &user.QingyuGetRelationFollowListRequest{
		ViewerId: viewId.(int64),
		OwnerId:  req.UserID,
	})
	if err != nil {
		hlog.Error("api call user_srv failed,", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	resp := new(api.QingyuRelationFollowListResponse)
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	for _, v := range res.UserList {
		resp.UserList = append(resp.UserList, &base.User{
			ID:              v.Id,
			Name:            v.Name,
			FollowCount:     v.FollowCount,
			FollowerCount:   v.FollowerCount,
			IsFollow:        v.IsFollow,
			Avatar:          v.Avatar,
			BackgroundImage: v.BackgroundImage,
			Signature:       v.Signature,
			TotalFavorited:  v.TotalFavorited,
			WorkCount:       v.WorkCount,
			FavoriteCount:   v.FavoriteCount,
		})
	}
	c.JSON(consts.StatusOK, resp)
}

// FollowerList .
// @router /qingyu/relation/follower/list/ [GET]
func FollowerList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuRelationFollowerListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api followerList bindAndValidate failed,", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	viewId, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get viewerId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}
	res, err := config.GlobalUserClient.GetFollowerList(ctx, &user.QingyuGetRelationFollowerListRequest{
		ViewerId: viewId.(int64),
		OwnerId:  req.UserID,
	})
	if err != nil {
		hlog.Error("api call user_srv failed,", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	resp := new(api.QingyuRelationFollowerListResponse)
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	for _, v := range res.UserList {
		resp.UserList = append(resp.UserList, &base.User{
			ID:              v.Id,
			Name:            v.Name,
			FollowCount:     v.FollowCount,
			FollowerCount:   v.FollowerCount,
			IsFollow:        v.IsFollow,
			Avatar:          v.Avatar,
			BackgroundImage: v.BackgroundImage,
			Signature:       v.Signature,
			TotalFavorited:  v.TotalFavorited,
			WorkCount:       v.WorkCount,
			FavoriteCount:   v.FavoriteCount,
		})
	}

	c.JSON(consts.StatusOK, resp)
}

// FriendList .
// @router /qingyu/relation/friend/list/ [GET]
func FriendList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuRelationFriendListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api friendList bindAndValidate failed,", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	viewId, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get viewerId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}
	res, err := config.GlobalUserClient.GetFriendList(ctx, &user.QingyuGetRelationFriendListRequest{
		ViewerId: viewId.(int64),
		OwnerId:  req.UserID,
	})
	if err != nil {
		hlog.Error("api call user_srv failed,", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	resp := new(api.QingyuRelationFriendListResponse)
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	for _, v := range res.UserList {
		resp.UserList = append(resp.UserList, &base.FriendUser{
			ID:              v.Id,
			Name:            v.Name,
			FollowCount:     v.FollowCount,
			FollowerCount:   v.FollowerCount,
			IsFollow:        v.IsFollow,
			Avatar:          v.Avatar,
			BackgroundImage: v.BackgroundImage,
			Signature:       v.Signature,
			TotalFavorited:  v.TotalFavorited,
			WorkCount:       v.WorkCount,
			FavoriteCount:   v.FavoriteCount,
			Message:         v.Message,
			MsgType:         v.MsgType,
		})
	}

	c.JSON(consts.StatusOK, resp)
}

// ChatHistory .
// @router /qingyu/message/chat/ [GET]
func ChatHistory(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuMessageChatRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api chatHistory bindAndValidate failed,", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	viewId, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get viewerId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}
	res, err := config.GlobalChatClient.GetChatHistory(ctx, &chat.QingyuMessageGetChatHistoryRequest{
		UserId:     viewId.(int64),
		ToUserId:   req.ToUserID,
		PreMsgTime: req.PreMsgTime,
	})
	if err != nil {
		hlog.Error("api call chat rpc failed,", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	resp := new(api.QingyuMessageChatResponse)
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	for _, v := range res.MessageList {
		resp.MessageList = append(resp.MessageList, &base.Message{
			ID:         v.Id,
			ToUserID:   v.ToUserId,
			FromUserID: v.FromUserId,
			Content:    v.Content,
			CreateTime: v.CreateTime,
		})
	}
	c.JSON(consts.StatusOK, resp)
}

// SentMessage .
// @router /qingyu/message/action/ [POST]
func SentMessage(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuMessageActionRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api sentMessage failed,", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	viewId, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get viewerId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}
	res, err := config.GlobalChatClient.SentMessage(ctx, &chat.QingyuMessageActionRequest{
		UserId:     viewId.(int64),
		ToUserId:   req.ToUserID,
		ActionType: req.ActionType,
		Content:    req.Content,
	})
	if err != nil {
		hlog.Error("api call chat rpc failed,", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	resp := new(api.QingyuMessageActionResponse)
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	c.JSON(consts.StatusOK, resp)
}

// UpdateIssueList .
// @router /qingyu/issuelist/action/ [POST]
func UpdateIssueList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuIssueListUpdateRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api update issueList failed,", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	userId, _ := strconv.ParseInt(req.IssueList.UserID, 10, 64)
	var issueList user.QingyuUpdateIssueListRequest
	issueList.IssueList = new(base2.IssueList)
	err = copier.Copy(issueList.IssueList, req.IssueList)
	if err != nil {
		fmt.Println(err)
		return
	}
	issueList.UserId = userId
	res, err := config.GlobalUserClient.UpdateIssueList(ctx, &issueList)
	resp := new(api.QingyuIssueListUpdateResponse)
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	c.JSON(consts.StatusOK, resp)
}

// GetIssueList .
// @router /qingyu/issuelist/ [GET]
func GetIssueList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuIssueListGetRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api get issueList failed,", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	_, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get viewerId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}
	res, err := config.GlobalUserClient.GetIssueList(ctx, &user.QingyuGetIssueListRequest{UserId: req.UserID})
	resp := new(api.QingyuIssueListGetResponse)
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	if res.IssueList == nil {
		c.JSON(consts.StatusOK, resp)
		return
	}
	resp.IssueList = new(base.IssueList)
	err = copier.Copy(resp.IssueList, res.IssueList)
	if err != nil {
		if errors.Is(err, copier.ErrInvalidCopyDestination) {
			c.JSON(consts.StatusOK, resp)
			return
		}
		hlog.Error("api copy issueList failed,", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	c.JSON(consts.StatusOK, resp)
}

// SearchUserList .
// @router /qingyu/user/search [POST]
func SearchUserList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuSearchUserRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	userID, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get viewerId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}
	res, err := config.GlobalUserClient.SearchUserList(ctx, &user.QingyuSearchUserRequest{ViewerId: userID.(int64), Content: req.Content, Offset: req.Offset, Num: req.Num})
	resp := new(api.QingyuSearchUserResponse)
	resp.UserList = make([]*base.User, 0)
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	for _, v := range res.UserList {
		resp.UserList = append(resp.UserList, &base.User{
			ID:              v.Id,
			Name:            v.Name,
			FollowCount:     0,
			FollowerCount:   0,
			IsFollow:        false,
			Avatar:          v.Avatar,
			BackgroundImage: v.BackgroundImage,
			Signature:       v.Signature,
			TotalFavorited:  0,
			WorkCount:       0,
			FavoriteCount:   0,
		})
	}
	c.JSON(consts.StatusOK, resp)
}

// SearchVideoList .
// @router /qingyu/user/search [POST]
func SearchVideoList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuSearchVideoRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	userID, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get viewerId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}
	res, err := config.GlobalVideoClient.SearchVideoList(ctx, &video.QingyuSearchVideoRequest{ViewerId: userID.(int64), Content: req.Content, Offset: req.Offset, Num: req.Num})
	resp := new(api.QingyuSearchVideoResponse)
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	for _, v := range res.VideoList {
		resp.VideoList = append(resp.VideoList, &base.Video{
			ID:            v.Id,
			Author:        &base.User{ID: v.Author.Id},
			PlayURL:       v.PlayUrl,
			CoverURL:      v.CoverUrl,
			FavoriteCount: 0,
			CommentCount:  0,
			IsFavorite:    false,
			Title:         v.Title,
		})
	}
	c.JSON(consts.StatusOK, resp)
}

// ChangeAvatar .
// @router /qingyu/user/avatar [POST]
func ChangeAvatar(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuAvatarChangeRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api bind failed,", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp := new(api.QingyuAvatarChangeResponse)
	userId, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get userId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}
	avatarFile, err := c.Request.FormFile("avatar")
	if err != nil {
		hlog.Error("api read avatar file failed,err", err)
		resp.StatusCode = 500
		resp.StatusMsg = "read avatar file failed"
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	file, err := avatarFile.Open()
	if err != nil {
		hlog.Error("api open avatar file failed,err", err)
		resp.StatusCode = 500
		resp.StatusMsg = "read avatar file failed"
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	suffix := strings.Split(avatarFile.Filename, ".")
	filename := "avatar/" + strconv.FormatInt(userId.(int64), 10) + "." + suffix[len(suffix)-1]
	err = pkg.MinioAvatarUpgrade(file, filename, avatarFile.Size, suffix[len(suffix)-1])
	if err != nil {
		hlog.Error("api upgrade avatar failed,err", err)
		resp.StatusCode = 500
		resp.StatusMsg = "api upgrade avatar failed"
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	res, err := config.GlobalUserClient.ChangeUserAvatar(ctx, &user.QingyuAvatarChangeRequest{UserId: userId.(int64), Avatar: config.GlobalServerConfig.MinioInfo.UrlPrefix + filename})
	if err != nil {
		hlog.Error("api upgrade avatar failed,err", err)
		resp.StatusCode = 500
		resp.StatusMsg = "api upgrade avatar failed"
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	c.JSON(consts.StatusOK, resp)
}

// AIGCAskQuestion .
// @router /qingyu/aigc/question/ [POST]
func AIGCAskQuestion(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuAigcQuestionRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	userId, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get viewerId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}
	resp := new(api.QingyuAigcQuestionResponse)

	res, err := config.GlobalAIGCClient.UserAskQuestion(ctx, &aigc.QingyuAigcQuestionRequest{UserId: userId.(int64), Content: req.Content})
	if err != nil {
		hlog.Error("api UserAskQuestion failed,", err)
		return
	}
	resp.Msg = res.Msg
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode

	c.JSON(consts.StatusOK, resp)
}

// AIGCIssueList .
// @router /qingyu/aigc/issuelist [GET]
func AIGCIssueList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuAigcIssueListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	userId, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get viewerId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}

	resp := new(api.QingyuAigcIssueListResponse)

	res, err := config.GlobalAIGCClient.AnalyseIssueList(ctx, &aigc.QingyuAigcIssueListRequest{UserId: userId.(int64)})
	if err != nil {
		return
	}
	resp.Msg = res.Msg
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	c.JSON(consts.StatusOK, resp)
}

// AIGCChooseWord .
// @router /qingyu/aigc/word/ [POST]
func AIGCChooseWord(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuAigcChooseWordRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	userId, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get viewerId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}

	resp := new(api.QingyuAigcChooseWordResponse)

	res, err := config.GlobalAIGCClient.ChooseWord(ctx, &aigc.QingyuAigcChooseWordRequest{UserId: userId.(int64), Content: req.Content})
	if err != nil {
		return
	}
	resp.Msg = res.Msg
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	c.JSON(consts.StatusOK, resp)
}

// AIGCDoctorAnalyse .
// @router /qingyu/aigc/doctor [POST]
func AIGCDoctorAnalyse(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuAigcDoctorAnalyseRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	userId, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get viewerId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}

	resp := new(api.QingyuAigcDoctorAnalyseResponse)

	res, err := config.GlobalAIGCClient.DoctorAnalyse(ctx, &aigc.QingyuAigcDoctorAnalyseRequest{UserId: userId.(int64), Content: req.Content})
	if err != nil {
		return
	}
	resp.Msg = res.Msg
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	c.JSON(consts.StatusOK, resp)
}

// AIGCGetHistory .
// @router /qingyu/aigc/history [GET]
func AIGCGetHistory(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.QingyuAigcGetHistoryRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	userId, flag := c.Get("userId")
	if !flag {
		hlog.Error("api get viewerId failed,", err)
		c.String(consts.StatusBadRequest, errors.New("api context get viewerId failed").Error())
		return
	}

	resp := new(api.QingyuAigcGetHistoryResponse)

	res, err := config.GlobalAIGCClient.GetAIGCHistory(ctx, &aigc.QingyuAigcGetHistoryRequest{UserId: userId.(int64)})
	if err != nil {
		return
	}
	resp.Msg = res.Msg
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode
	c.JSON(consts.StatusOK, resp)
}
